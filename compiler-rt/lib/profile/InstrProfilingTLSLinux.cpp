#if defined(__linux__) || defined(__FreeBSD__) || defined(__Fuchsia__) || \
    (defined(__sun__) && defined(__svr4__)) || defined(__NetBSD__) || \
    defined(_AIX)

#include <elf.h>
#include <link.h>
#endif
#include <stdlib.h>
#include <string.h>

extern "C" {

#include "InstrProfiling.h"
#include "InstrProfilingInternal.h"
}

#include "interception/interception.h"

static void register_profile_intercepts();

extern "C" {

#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)

#define PROF_TLS_CNTS_START INSTR_PROF_SECT_START(INSTR_PROF_TLS_CNTS_COMMON)
#define PROF_TLS_CNTS_STOP INSTR_PROF_SECT_STOP(INSTR_PROF_TLS_CNTS_COMMON)
#define PROF_CNTS_START INSTR_PROF_SECT_START(INSTR_PROF_CNTS_COMMON)
#define PROF_CNTS_STOP INSTR_PROF_SECT_STOP(INSTR_PROF_CNTS_COMMON)


// Clarity:  This is where the tls counters SECTION begins.  This
// is not where the TLS section for this module begins on this thread-
// it's merely useful for calculating the offset of 
// __llvm_prf_tls_cnts in the PH_TLS program header.


char *tls_pubvis_profile_begin_tls_counters(void) {
    return __llvm_profile_begin_tls_counters();
}

char *tls_pubvis_profile_end_tls_counters(void) {
    return __llvm_profile_end_tls_counters();
}

char *tls_pubvis_profile_begin_counters(void) {
    return __llvm_profile_begin_counters();
}

char *tls_pubvis_profile_end_counters(void) {
    return __llvm_profile_end_counters();
}

uint64_t tls_pubvis_profile_get_num_counters(const char *begin, const char *end) {
    return __llvm_profile_get_num_counters(begin, end);
}

static int get_counters_begin_and_end(const char *mod_name, char **tls_begin, char **tls_end, char **cnts_begin, char **cnts_end, uint64_t *num_counters) {

    char *(*tls_begin_f)(void) = NULL;
    char *(*tls_end_f)(void) = NULL;
    char *(*cnts_begin_f)(void) = NULL;
    char *(*cnts_end_f)(void) = NULL;
    uint64_t (*num_counters_f)(const char *, const char *) = NULL;
    if (strcmp(mod_name, "") == 0) {
        tls_begin_f = __llvm_profile_begin_tls_counters;
        tls_end_f = __llvm_profile_end_tls_counters;
        cnts_begin_f = __llvm_profile_begin_counters;
        cnts_end_f = __llvm_profile_end_counters;
        num_counters_f = __llvm_profile_get_num_counters;
    } else {
        void *handle = dlopen(mod_name, RTLD_LAZY | RTLD_NOLOAD);
        if (handle == NULL) {
            return 0;
        }

        tls_begin_f = (char *(*)(void))dlsym(handle, "tls_pubvis_profile_begin_tls_counters");
        tls_end_f = (char *(*)(void))dlsym(handle, "tls_pubvis_profile_end_tls_counters");
        cnts_begin_f = (char *(*)(void))dlsym(handle, "tls_pubvis_profile_begin_counters");
        cnts_end_f = (char *(*)(void))dlsym(handle, "tls_pubvis_profile_end_counters");
        num_counters_f = (uint64_t (*)(const char *, const char *))dlsym(handle, "tls_pubvis_profile_get_num_counters");

        dlclose(handle);
    }

     if (tls_begin_f == NULL || tls_end_f == NULL || cnts_begin_f == NULL || cnts_end_f == NULL || num_counters_f == NULL) {
        return 0;
    }
   
    // TODO maybe?:
    // __llvm_profile_get_num_counters
    // __llvm_profile_get_counters_size

    *tls_begin = tls_begin_f();
    *tls_end = tls_end_f();
    *cnts_begin = cnts_begin_f();
    *cnts_end = cnts_end_f();
    *num_counters = num_counters_f(*tls_begin, *tls_end);
/*
    *tls_begin = (char *) dlsym(handle, TOSTRING(PROF_TLS_CNTS_START));
    *tls_end = (char *) dlsym(handle, TOSTRING(PROF_TLS_CNTS_STOP));
    *cnts_begin = (char *) dlsym(handle, TOSTRING(PROF_CNTS_START));
    *cnts_end = (char *) dlsym(handle, TOSTRING(PROF_CNTS_STOP));
    if (*tls_begin == NULL || *tls_end == NULL || *cnts_begin == NULL || *cnts_end == NULL) {
        return 0;
    }

    uint64_t num_bytes = (uint64_t) tls_end - (uint64_t) tls_begin;
    *num_counters = num_bytes / sizeof(uint64_t);
*/
    return 1;
}

// This bad boy will be generated by the linker.
extern void *__tls_get_addr(size_t *);

static int AddCountersPerModule_cb(struct dl_phdr_info *info, size_t size, void *data) {
    const Elf64_Phdr *hdr = info->dlpi_phdr;
    const Elf64_Phdr *last_hdr = hdr + info->dlpi_phnum;

    const Elf64_Phdr *tls_hdr;
    for (; hdr != last_hdr; ++hdr) {
        if (hdr->p_type == PT_TLS) {
            tls_hdr = hdr;
            goto found_tls_ph;
        }
    }
    return 0;
found_tls_ph:

    char *tls_cnts_begin = NULL;
    char *tls_cnts_end = NULL;
    char *cnts_begin = NULL;
    char *cnts_end = NULL;
    uint64_t num_counters = 0;
    if (get_counters_begin_and_end(info->dlpi_name, &tls_cnts_begin, &tls_cnts_end, &cnts_begin, &cnts_end, &num_counters) == 0) {
        return 0;
    }

    uint64_t ph_true_vaddr = (uint64_t) info->dlpi_addr + (uint64_t) tls_hdr->p_vaddr;
    // Offset of __llvm_prf_tls_cnts into the TLS block for this module
    uint64_t tls_cnts_tlsblk_offset = (uint64_t) tls_cnts_begin - ph_true_vaddr;

    /* sketch tls_get_addr version
    size_t tls_index[2] = {0};
    tls_index[0] = info->dlpi_tls_modid;
    tls_index[1] = tls_cnts_tlsblk_offset;
    void *tls_prf_cnts_modlocal_begin = __tls_get_addr(tls_index);
    */
    uint64_t tls_prf_cnts_modlocal_begin = (uint64_t) info->dlpi_tls_data + tls_cnts_tlsblk_offset;

    // TODO: implemented for uint64_t counters only for now, but that ain't right long term cuz
    uint64_t *tls_cnt = (uint64_t *) tls_prf_cnts_modlocal_begin;
    uint64_t *tls_end = (uint64_t *) tls_cnt + num_counters;
    uint64_t *cnt = (uint64_t *) cnts_begin;
    for (; tls_cnt != tls_end; tls_cnt++, cnt++) {
        __atomic_fetch_add(cnt, *tls_cnt, __ATOMIC_RELAXED);
    }
    return 0;
}

void __llvm_profile_tls_counters_finalize(void) {
    dl_iterate_phdr(AddCountersPerModule_cb, NULL);
}

struct pthread_wrapper_arg {
    void *(*fn)(void *);
    void *arg;
    uint32_t arg_keepalive;
};

void *pthread_fn_wrapper(void *arg_ptr) {
    struct pthread_wrapper_arg *wrapper_arg = (struct pthread_wrapper_arg *) arg_ptr;
    void *(*fn)(void *) = __atomic_load_n(&wrapper_arg->fn, __ATOMIC_RELAXED);
    void *arg = __atomic_load_n(&wrapper_arg->arg, __ATOMIC_RELAXED);
    __atomic_store_n(&wrapper_arg->arg_keepalive, 0, __ATOMIC_RELEASE);

    // startup
    // Do nothing (TLS is automatically loaded and zeroed)
    void *retval = fn(arg);
    // cleanup
    __llvm_profile_tls_counters_finalize();
    // Combine counters with main counters
    return retval;
}

void __llvm_register_profile_intercepts() {
    register_profile_intercepts();
}

} // end extern "C"

INTERCEPTOR(int, pthread_create, void *thread, void *attr, void *(*start_routine)(void *), void *arg) {
    int res = -1;
    struct pthread_wrapper_arg wrapper_arg = {
        (void *(*)(void *)) start_routine,
        arg,
        1
    };

    // do pthread
    res = REAL(pthread_create)(thread, attr, pthread_fn_wrapper, &wrapper_arg);
    // Spin wait for child thread to copy arguments
    while (__atomic_load_n(&wrapper_arg.arg_keepalive, __ATOMIC_ACQUIRE) == 1);
    return res;
}

static void register_profile_intercepts() {
    INTERCEPT_FUNCTION(pthread_create);
}
